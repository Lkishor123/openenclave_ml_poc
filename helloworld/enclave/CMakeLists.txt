# ~/openenclave_ml_poc/helloworld/enclave/CMakeLists.txt

cmake_minimum_required(VERSION 3.16)

# Define the name for your enclave executable (unsigned)
set(ENCLAVE_NAME helloworld_enclave)

# List the source files for the enclave.
set(ENCLAVE_SOURCES
    enc.c
    ${EDL_TRUSTED_C} # Generated by root CMakeLists.txt, path is available
)
# The trusted header (e.g., helloworld_t.h) will be included by enc.c from the
# EDL_GENERATED_DIR which was added to include_directories in the root CMakeLists.txt.

# Create the unsigned enclave executable
add_executable(${ENCLAVE_NAME} ${ENCLAVE_SOURCES})

# Link the enclave executable against the required Open Enclave libraries.
target_link_libraries(${ENCLAVE_NAME} PRIVATE openenclave::oeenclave openenclave::oelibc)

# Optional: Set the Open Enclave API version
# target_compile_definitions(${ENCLAVE_NAME} PRIVATE OE_API_VERSION=2)

# Ensure that EDL generation is completed before attempting to build this enclave.
add_dependencies(${ENCLAVE_NAME} GenerateEDL)

message(STATUS "Configuring Enclave (using add_executable): ${ENCLAVE_NAME}")
message(STATUS "  Enclave sources: ${ENCLAVE_SOURCES}")
message(STATUS "  Unsigned enclave executable: ${ENCLAVE_NAME}")

# --- Enclave Signing ---
# 1. Define the path to your enclave configuration file.
# This file specifies settings for the enclave (ProductID, SecurityVersion, Debug, etc.).
# It should be placed in the same directory as this CMakeLists.txt (i.e., helloworld/enclave/).
set(ENCLAVE_CONF_FILE ${CMAKE_CURRENT_SOURCE_DIR}/helloworld.conf)

# 2. Define the path to your private signing key.
# It should also be placed in helloworld/enclave/ for this example.
# For production, manage keys securely and do NOT commit them to your repository.
set(ENCLAVE_PRIVATE_KEY_FILE ${CMAKE_CURRENT_SOURCE_DIR}/private.pem)

# (Optional) Example: Generate a private key for signing (for demonstration purposes only).
# If private.pem doesn't exist, these commands can create one.
# Requires OpenSSL command-line tool.
find_package(OpenSSL) # Find OpenSSL for the openssl executable
if(OpenSSL_FOUND)
    add_custom_command(OUTPUT ${ENCLAVE_PRIVATE_KEY_FILE} # Also outputs public.pem for completeness
        COMMAND ${OpenSSL_EXECUTABLE} genrsa -out ${ENCLAVE_PRIVATE_KEY_FILE} -3 3072
        # COMMAND ${OpenSSL_EXECUTABLE} rsa -in ${ENCLAVE_PRIVATE_KEY_FILE} -pubout -out ${CMAKE_CURRENT_SOURCE_DIR}/public.pem
        WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} # Output key in source dir for this example
        COMMENT "Generating self-signed key pair (private.pem) for enclave signing (DEMO ONLY if key not present)"
        VERBATIM)
    # This custom command only runs if private.pem is missing.
    # To make it a target that you can explicitly call, wrap it in add_custom_target.
    # add_custom_target(GenerateEnclaveKey DEPENDS ${ENCLAVE_PRIVATE_KEY_FILE})
else()
    message(WARNING "OpenSSL not found. Cannot generate demo private key. Ensure ${ENCLAVE_PRIVATE_KEY_FILE} exists.")
endif()


# 3. Define the output path for the signed enclave.
# The signed enclave is typically named with a .signed.so suffix.
# It will be placed in the build directory for the enclave (e.g., build/enclave/).
set(SIGNED_ENCLAVE_FILE ${CMAKE_CURRENT_BINARY_DIR}/${ENCLAVE_NAME}.signed.so)

# 4. Add a custom command to sign the enclave using openenclave::oesign.
# This command runs after the unsigned enclave (${ENCLAVE_NAME}) is built and
# if the .conf file or private key changes.
add_custom_command(OUTPUT ${SIGNED_ENCLAVE_FILE}
    DEPENDS
        ${ENCLAVE_NAME}                 # Depends on the unsigned enclave executable
        ${ENCLAVE_CONF_FILE}            # Depends on the enclave configuration file
        ${ENCLAVE_PRIVATE_KEY_FILE}     # Depends on the private key
    COMMAND openenclave::oesign sign    # Use the imported target
            -e $<TARGET_FILE:${ENCLAVE_NAME}>   # Path to the unsigned enclave executable
            -c ${ENCLAVE_CONF_FILE}             # Path to the enclave configuration file
            -k ${ENCLAVE_PRIVATE_KEY_FILE}      # Path to your private key file
    # The output file (${SIGNED_ENCLAVE_FILE}) will be placed next to the unsigned enclave by default.
    COMMENT "Signing enclave ${ENCLAVE_NAME} -> ${SIGNED_ENCLAVE_FILE}"
    VERBATIM)

# 5. Add a custom target to ensure the signing command is executed.
# The 'ALL' keyword makes this target part of the default build.
# This target depends on the output file of the signing command.
add_custom_target(${ENCLAVE_NAME}_signed ALL
    DEPENDS ${SIGNED_ENCLAVE_FILE})

message(STATUS "  Signed enclave will be: ${SIGNED_ENCLAVE_FILE}")
message(STATUS "  Ensure ${ENCLAVE_CONF_FILE} and ${ENCLAVE_PRIVATE_KEY_FILE} exist for signing.")
