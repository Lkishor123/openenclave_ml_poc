name: ci-cd-azure

on:
  push:
    branches: [ main ]
  workflow_dispatch: {}

permissions:
  id-token: write
  contents: read
  packages: write

env:
  TF_WORKING_DIR: terraform
  GHCR_OWNER: ${{ github.repository_owner }}
  GHCR_FRONTEND_IMAGE: openenclave-frontend
  GHCR_BACKEND_IMAGE: openenclave-backend

jobs:
  build_and_push:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Lowercase repo owner for GHCR
        id: owner
        run: echo "owner_lc=${GITHUB_REPOSITORY_OWNER,,}" >> $GITHUB_OUTPUT

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_USERNAME }}
          password: ${{ secrets.GHCR_PAT }}

      - name: Build & push FRONTEND
        uses: docker/build-push-action@v6
        with:
          context: ./sentiment-analysis-frontend
          push: true
          build-args: |
            NEXT_PUBLIC_SUPABASE_URL=${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
            NEXT_PUBLIC_SUPABASE_ANON_KEY=${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
            NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL }}
          tags: |
            ghcr.io/${{ steps.owner.outputs.owner_lc }}/${{ env.GHCR_FRONTEND_IMAGE }}:${{ github.sha }}
            ghcr.io/${{ steps.owner.outputs.owner_lc }}/${{ env.GHCR_FRONTEND_IMAGE }}:latest
      - name: Backend assets | download model/tokenizer
        run: |
          set -e
          cd sentiment-analysis-backend
          bash download_deps.sh

      - name: Build & push BACKEND
        uses: docker/build-push-action@v6
        with:
          context: ./sentiment-analysis-backend
          push: true
          tags: |
            ghcr.io/${{ steps.owner.outputs.owner_lc }}/${{ env.GHCR_BACKEND_IMAGE }}:${{ github.sha }}
            ghcr.io/${{ steps.owner.outputs.owner_lc }}/${{ env.GHCR_BACKEND_IMAGE }}:latest

    outputs:
      image_tag: ${{ github.sha }}
      owner_lc: ${{ steps.owner.outputs.owner_lc }}

  terraform_apply:
    needs: build_and_push
    runs-on: ubuntu-latest
    env:
      ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
      ARM_TENANT_ID:       ${{ secrets.ARM_TENANT_ID }}
      ARM_CLIENT_ID:       ${{ secrets.ARM_CLIENT_ID }}
      ARM_CLIENT_SECRET:   ${{ secrets.ARM_CLIENT_SECRET }}
      TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
      ARM_ACCESS_KEY: ${{ secrets.TFSTATE_ACCESS_KEY }}

    steps:
      - uses: actions/checkout@v4

      # - name: Azure login (OIDC optional)
      #   uses: azure/login@v2
      #   with:
      #     client-id:     ${{ secrets.ARM_CLIENT_ID }}
      #     tenant-id:     ${{ secrets.ARM_TENANT_ID }}
      #     subscription-id: ${{ secrets.ARM_SUBSCRIPTION_ID }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Terraform Init
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          terraform init -upgrade \
            -backend-config="resource_group_name=ccopenenclave" \
            -backend-config="storage_account_name=tfstate123321nov12" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=openenclave-ml-poc.tfstate"

      - name: Terraform Plan
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform plan -out tfplan

      - name: Terraform Apply
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform apply -auto-approve tfplan

      - name: Capture public IP
        id: tfout
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: echo "PUBLIC_IP=$(terraform output -raw public_ip)" >> $GITHUB_OUTPUT

    outputs:
      vm_ip: ${{ steps.tfout.outputs.PUBLIC_IP }}
      image_tag: ${{ needs.build_and_push.outputs.image_tag }}

  deploy_vm:
    needs: terraform_apply
    runs-on: ubuntu-latest
    env:
      GHCR_OWNER:          ${{ needs.build_and_push.outputs.owner_lc }}
      GHCR_FRONTEND_IMAGE: openenclave-frontend
      GHCR_BACKEND_IMAGE:  openenclave-backend
      IMAGE_TAG:           ${{ needs.terraform_apply.outputs.image_tag }}
      VM_USER:             ${{ secrets.VM_ADMIN_USERNAME }}
      VM_HOST:             ${{ needs.terraform_apply.outputs.vm_ip }}
    steps:
      - name: Wait for SSH (port 22)
        run: |
          echo "Probing ${{ env.VM_HOST }}:22 ..."
          for i in {1..30}; do
            if timeout 2 bash -lc "echo > /dev/tcp/${{ env.VM_HOST }}/22" 2>/dev/null; then
              echo "SSH is up."
              exit 0
            fi
            echo "Waiting for SSH... ($i/30)"
            sleep 3
          done
          echo "SSH did not come up in time." >&2
          exit 1

      - name: SSH smoke test
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.VM_HOST }}
          username: ${{ env.VM_USER }}
          key: ${{ secrets.VM_SSH_PRIVATE_KEY }}
          port: 22
          script_stop: true
          timeout: 60s
          command_timeout: 2m
          debug: true
          script: |
            set -e
            whoami
            uname -a

      # 2) Deploy
      - name: Create env files & compose up (remote)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.VM_HOST }}
          username: ${{ env.VM_USER }}
          key: ${{ secrets.VM_SSH_PRIVATE_KEY }}   # <â€” IMPORTANT
          port: 22
          script_stop: true
          timeout: 60s
          command_timeout: 30m
          debug: true
          script: |
            set -euo pipefail

            sudo mkdir -p /opt/app
            sudo chown $USER:$USER /opt/app

            # .env
            printf '%s\n' \
            'NEXT_PUBLIC_SUPABASE_URL=${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}' \
            'NEXT_PUBLIC_SUPABASE_ANON_KEY=${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}' \
            'NEXT_PUBLIC_API_URL=http://${{ env.VM_HOST }}:8080/api/analyze' \
            'SUPABASE_JWT_SECRET=${{ secrets.SUPABASE_JWT_SECRET }}' \
            | tee /opt/app/.env >/dev/null

            # .env.backend
            printf '%s\n' \
            'SUPABASE_JWT_SECRET=${{ secrets.SUPABASE_JWT_SECRET }}' \
            'ALLOWED_ORIGIN="http://${{ env.VM_HOST }}:3000"' \
            | tee /opt/app/.env.backend >/dev/null

            # Login to GHCR (use PAT owner username)
            echo "${{ secrets.GHCR_PAT }}" | docker login ghcr.io -u "${{ secrets.GHCR_USERNAME }}" --password-stdin

            # Be sure Docker is up (first boot can race)
            until sudo systemctl is-active --quiet docker; do echo "waiting for docker..."; sleep 3; done

            # Write docker-compose.deploy.yml without heredoc
            printf '%s\n' \
            'version: "3.8"' \
            'services:' \
            '  frontend:' \
            '    image: ghcr.io/${{ env.GHCR_OWNER }}/${{ env.GHCR_FRONTEND_IMAGE }}:${{ env.IMAGE_TAG }}' \
            '    env_file:' \
            '      - /opt/app/.env' \
            '    ports: [ "3000:3000" ]' \
            '    networks: [ sentiment-net ]' \
            '    depends_on: [ backend ]' \
            '    restart: unless-stopped' \
            '  backend:' \
            '    image: ghcr.io/${{ env.GHCR_OWNER }}/${{ env.GHCR_BACKEND_IMAGE }}:${{ env.IMAGE_TAG }}' \
            '    env_file:' \
            '      - /opt/app/.env.backend' \
            '    devices:' \
            '      - "/dev/sgx_enclave:/dev/sgx_enclave"' \
            '      - "/dev/sgx_provision:/dev/sgx_provision"' \
            '    ports: [ "8080:8080" ]' \
            '    networks: [ sentiment-net ]' \
            '    restart: unless-stopped' \
            'networks:' \
            '  sentiment-net:' \
            '    driver: bridge' \
            | tee /opt/app/docker-compose.deploy.yml >/dev/null

            docker compose -f /opt/app/docker-compose.deploy.yml pull
            docker compose -f /opt/app/docker-compose.deploy.yml up -d
