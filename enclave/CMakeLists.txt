# enclave/CMakeLists.txt
cmake_minimum_required(VERSION 3.16)

set(ENCLAVE_NAME enclave_prod) # Basename for the enclave .so file
set(ENCLAVE_SOURCES
    enclave.cpp
    ${EDL_TRUSTED_C} # Generated by root CMakeLists.txt
)
set(ENCLAVE_HEADERS
    ${EDL_TRUSTED_H} # Generated by root CMakeLists.txt
)

# Add enclave using Open Enclave's CMake function
# This function handles compilation, linking, and signing for the enclave.
add_enclave(${ENCLAVE_NAME}
    SOURCES ${ENCLAVE_SOURCES}
    HEADERS ${ENCLAVE_HEADERS}
    # USER_INCLUDES are handled by include_directories(${EDL_GENERATED_DIR}) in root CMakeLists.txt
    # and target_include_directories for ONNX Runtime below.
)

# Include ONNX Runtime headers for the enclave
# The enclave code uses the ONNX Runtime C API, so it needs the headers.
# It does NOT link against libonnxruntime.so directly. That's a host concern.
# The GLOBAL_ONNXRUNTIME_INCLUDE_DIR is set in the root CMakeLists.txt
if(GLOBAL_ONNXRUNTIME_INCLUDE_DIR AND EXISTS "${GLOBAL_ONNXRUNTIME_INCLUDE_DIR}")
    target_include_directories(${ENCLAVE_NAME} PRIVATE ${GLOBAL_ONNXRUNTIME_INCLUDE_DIR})
    message(STATUS "Enclave (${ENCLAVE_NAME}): Added ONNX Runtime include directory: ${GLOBAL_ONNXRUNTIME_INCLUDE_DIR}")
else()
    message(WARNING "Enclave (${ENCLAVE_NAME}): GLOBAL_ONNXRUNTIME_INCLUDE_DIR not set or invalid. Compilation might fail if onnxruntime_c_api.h is not found.")
endif()

# Enclave signing:
# oe_add_enclave handles basic signing.
# For production, you MUST use a securely managed private key.
# You can specify a key file:
# set(ENCLAVE_SIGNER_KEY_PATH "${CMAKE_CURRENT_SOURCE_DIR}/enclave.signer.pem") # Example path
# if(EXISTS ${ENCLAVE_SIGNER_KEY_PATH})
#   oe_sign_enclave(${ENCLAVE_NAME} KEY_FILE ${ENCLAVE_SIGNER_KEY_PATH})
#   message(STATUS "Enclave (${ENCLAVE_NAME}): Will be signed with ${ENCLAVE_SIGNER_KEY_PATH}")
# else()
#   message(WARNING "Enclave (${ENCLAVE_NAME}): Signer key ${ENCLAVE_SIGNER_KEY_PATH} not found. oe_add_enclave might use a default or generate one (not for production).")
# endif()
# For this example, we rely on oe_add_enclave's default behavior or a key provided/generated in the source dir.
# Ensure enclave.signer.pem is present or generated for development.
# For production, the key should NOT be in the source repository.

# Ensure EDL generation target (defined in root CMakeLists.txt) is a dependency for building this enclave.
add_dependencies(${ENCLAVE_NAME} GenerateEDL)

# --- Build Type Specific Settings for Enclave ---
# OE SDK typically sets optimization flags based on CMAKE_BUILD_TYPE.
# For Release builds, ensure appropriate flags are used (e.g., -O2 or -O3, LTO if beneficial).
# For Debug builds, -O0 -g is typical.
# oe_add_enclave usually handles this.

# Example: Setting specific compiler flags for the enclave target
# target_compile_options(${ENCLAVE_NAME} PRIVATE
#   $<$<CONFIG:Debug>:-Og -g3>
#   $<$<CONFIG:Release>:-O2 -DNDEBUG> # -fno-omit-frame-pointer can be useful for release debugging
# )

# Output information
message(STATUS "Configuring Enclave: ${ENCLAVE_NAME}")
message(STATUS "  Enclave sources: ${ENCLAVE_SOURCES}")
message(STATUS "  Enclave will be signed and output as ${ENCLAVE_NAME}.signed.so in build/enclave/")
